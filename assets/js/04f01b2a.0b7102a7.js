"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[607],{5318:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3144:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var a=n(2685),i=n(1244),o=(n(7378),n(5318)),r=["components"],s={title:"Unit of Work",sidebar_position:1},l=void 0,c={unversionedId:"features/unit-of-work",id:"features/unit-of-work",title:"Unit of Work",description:"Joist's EntityManager acts as a Unit of Work, which caches the entities that are currently loaded/being mutated for each request.",source:"@site/docs/features/unit-of-work.md",sourceDirName:"features",slug:"/features/unit-of-work",permalink:"/docs/features/unit-of-work",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/features/unit-of-work.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Unit of Work",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Partial Update APIs",permalink:"/docs/querying/partial-update-apis"},next:{title:"Tagged Ids",permalink:"/docs/features/tagged-ids"}},d={},u=[{value:"Per-Request Entity Caching",id:"per-request-entity-caching",level:2},{value:"Data Consistency",id:"data-consistency",level:2},{value:"Automatically Batching Updates",id:"automatically-batching-updates",level:2},{value:"Automatically Using Transactions",id:"automatically-using-transactions",level:2},{value:"Note: Not a Shared/Distributed Cache",id:"note-not-a-shareddistributed-cache",level:2}],p={toc:u};function h(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Joist's ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," acts as a ",(0,o.kt)("a",{parentName:"p",href:"https://www.martinfowler.com/eaaCatalog/unitOfWork.html"},"Unit of Work"),", which caches the entities that are currently loaded/being mutated for each request."),(0,o.kt)("p",null,"This means that entities must be loaded from the ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager"),", i.e. via ",(0,o.kt)("inlineCode",{parentName:"p"},"em.load(Author, 1)"),", and not from methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"Author"),", i.e. like an ActiveRecord ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.find_by_id(1)"),", but there are four main reasons for this:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Per-request entity caching"),(0,o.kt)("li",{parentName:"ol"},"Data consistency"),(0,o.kt)("li",{parentName:"ol"},"Automatically batching updates"),(0,o.kt)("li",{parentName:"ol"},"Automatically using transactions ")),(0,o.kt)("h2",{id:"per-request-entity-caching"},"Per-Request Entity Caching"),(0,o.kt)("p",null,"Typically with Joist, one ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," is created per request, e.g. handling ",(0,o.kt)("inlineCode",{parentName:"p"},"POST /book/new")," creates one ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," to (say) load ",(0,o.kt)("inlineCode",{parentName:"p"},"em.load")," the new book's ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," (from the post data), create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," instance, and then save it to the database by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"em.flush()"),"."),(0,o.kt)("p",null,"Once created for a request, the ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," instance will cache each row it loads from the database, and not reload it, even if multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT * FROM books WHERE ..."),' queries bring back "the same row" twice.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const a = await em.find(Author, { id: "a:1" });\nconst b = await em.find(Author, { id: "a:1" });\nconst c = await em.load(Author, "a:1"); // no SQL call issued\nconst d = await book1.author.load(); // no SQL call issued\n// All print true\nconsole.log(a === b);\nconsole.log(a === c);\nconsole.log(a === d);\n')),(0,o.kt)("p",null,"This caching avoids reloading the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," from the database if other code loads it (for example validation rules within ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," calling ",(0,o.kt)("inlineCode",{parentName:"p"},"book.author.load()")," will avoid a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," call if the author for that ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," is already in the ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager"),")."),(0,o.kt)("p",null,"This caching also works for references & collections: for example if two places both call ",(0,o.kt)("inlineCode",{parentName:"p"},"a1.books.load()"),', because Joist has ensured there is only "one ',(0,o.kt)("inlineCode",{parentName:"p"},"a1")," instance\" for this request, we don't need to issue two ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT * FROM books WHERE author_id = 1")," queries."),(0,o.kt)("p",null,"Granted, in simple endpoints with no abstractions or complicated business logic, this caching is likely not a big deal; but once a codebase grows and access patterns get complicated (i.e. in GraphQL resolvers or validation rules/business logics), not constantly refetching the same ",(0,o.kt)("inlineCode",{parentName:"p"},"Author id=1")," row in the database is a nice win."),(0,o.kt)("h2",{id:"data-consistency"},"Data Consistency"),(0,o.kt)("p",null,"An additional upshot of entity caching (which focuses on avoiding reloads) is data consistency."),(0,o.kt)("p",null,"Specifically, because there is \"only one instance\" of an entity/row, any changes we've made to the entity are defacto by seen the rest of the endpoint's code."),(0,o.kt)("p",null,"Without this Unit-of-Work/",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager"),' pattern, it\'s possible for code to have "out of date" versions of an entity.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'function updateAuthor(a) {\n  a.firstName = "bob";\n}\n\nfunction outputAuthor(id) {\n  // if this was like Rails ActiveRecord, we get a different view of author\n  const a = Author.find_by_id(id)\n  // Now we\'ve output inconsistent/stale data\n  console.log(a.firstName)\n}\n\nconst a = Author.find_by_id(id)\nupdateAuthor(a)\noutputAuthor(id)\n')),(0,o.kt)("p",null,"With Joist, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.find_by_id(id)")," would be ",(0,o.kt)("inlineCode",{parentName:"p"},"em.load(Author, id)"),", which means we'd get back the existing ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," instance, and so can fundamentally no longer accidentally see old/stale data."),(0,o.kt)("p",null,'This pattern generally makes reasoning about "what have I changed so far?", "what is the latest version of the entity?" much easier, because when handling a given ',(0,o.kt)("inlineCode",{parentName:"p"},"POST")," / API update, you don't have to worry about various parts of your code having stale/different versions of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author"),"."),(0,o.kt)("h2",{id:"automatically-batching-updates"},"Automatically Batching Updates"),(0,o.kt)("p",null,"With Joist, each endpoint will generally make a single call to ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager.flush")," to save its changes."),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"em.flush")," call can seem like extra work, but it means Joist can:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Apply all validation rules to changed entities at once/in-parallel"),(0,o.kt)("li",{parentName:"ul"},"Issue batch ",(0,o.kt)("inlineCode",{parentName:"li"},"INSERT"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"UPDATE")," commands for all changed entities")),(0,o.kt)("h2",{id:"automatically-using-transactions"},"Automatically Using Transactions"),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager.flush"),", all ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT"),"s, ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s, and ",(0,o.kt)("inlineCode",{parentName:"p"},"DELETE"),"s for a single request are automatically applied with a single transaction."),(0,o.kt)("p",null,"Without this ",(0,o.kt)("inlineCode",{parentName:"p"},"flush")," pattern, endpoints need to explicitly opt-in to transactions by manually demarking when the transaction starts/stops, i.e. in Rails ActiveRecord:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"Account.transaction do\n  balance.save!\n  account.save!\nend\n")),(0,o.kt)("p",null,"And because it is opt-in, most endpoints forget/do not bother doing this."),(0,o.kt)("p",null,"However, transactions are so fundamental to the pleasantness of Postgres and relational databases, that Joist's assertion is that ",(0,o.kt)("strong",{parentName:"p"},"transactions should always be used by default"),", and not just opt-in."),(0,o.kt)("h2",{id:"note-not-a-shareddistributed-cache"},"Note: Not a Shared/Distributed Cache"),(0,o.kt)("p",null,"Note that, because it's intended to be used per-request, the ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," is not a shared/second-level cache, i.e. a cache that would be shared across multiple requests to your webapp/API to reduce calls to the relational database."),(0,o.kt)("p",null,"An ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager")," should only be used by a single request, and so the cache is request scoped."),(0,o.kt)("p",null,"Granted, shared/second-level caches can be a good idea, but it means you have to worry about cache invalidation and staleness strategies, so for now Joist avoids that complexity."))}h.isMDXComponent=!0}}]);