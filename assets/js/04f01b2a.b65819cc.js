"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[607],{5318:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var r=n(7378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),f=l(n),p=o,h=f["".concat(u,".").concat(p)]||f[p]||d[p]||a;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=f;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},3144:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return u},metadata:function(){return l},toc:function(){return c},default:function(){return f}});var r=n(5773),o=n(808),a=(n(7378),n(5318)),i=["components"],s={},u=void 0,l={unversionedId:"features/unit-of-work",id:"features/unit-of-work",isDocsHomePage:!1,title:"unit-of-work",description:"Unit of Work-Level Query Cache",source:"@site/docs/features/unit-of-work.md",sourceDirName:"features",slug:"/features/unit-of-work",permalink:"/joist-ts/docs/features/unit-of-work",editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/features/unit-of-work.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tagged Ids",permalink:"/joist-ts/docs/features/tagged-ids"},next:{title:"validation-rules",permalink:"/joist-ts/docs/features/validation-rules"}},c=[{value:"Unit of Work-Level Query Cache",id:"unit-of-work-level-query-cache",children:[],level:3}],d={toc:c};function f(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"unit-of-work-level-query-cache"},"Unit of Work-Level Query Cache"),(0,a.kt)("p",null,"If you issue the same ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager.find(Entity, { ...where... })")," call multiple times within a single unit of work, the database query will only be issued once, and then the cached value used for subsequent calls."),(0,a.kt)("p",null,"If you do an ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager.flush"),", that will reset the find cache b/c the commit may have caused the cached query results to have changed."),(0,a.kt)("p",null,"Note that this is not a shared/second-level cache, i.e. shared across multiple requests to your webapp/API, which can be a good idea but means you have to worry about cache invalidation and staleness strategies."),(0,a.kt)("p",null,"This cache is solely for queries issued with the current unit of work, and it is thrown away/re-created for each new Unit of Work, so there should not be any issues with stale data or need to invalidate the cache (beyond what Joist already does by invalidating it on each ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager.flush()")," call)."),(0,a.kt)("p",null,"(Pedantically, currently Joist's Unit of Work does not currently open a transaction until ",(0,a.kt)("inlineCode",{parentName:"p"},"flush"),' is started, so without that transactional isolation, Joist\'s UoW find cache may actually be "hiding" changed results (between ',(0,a.kt)("inlineCode",{parentName:"p"},"find")," 1 and ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," 2) than if it were to actually re-issue the query each time. That said, a) ideally/at some point Joist's UoW will use a transaction throughout, such that this isolation behavior of not noticing new changes is actually a desired feature (i.e. avoiding non-repeatable reads), and b) UoWs are assumed to be extremely short-lived, i.e. per request, so you should generally not be trying to observe changed results between ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," calls anyway.)"))}f.isMDXComponent=!0}}]);