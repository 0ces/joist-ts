"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[165],{5318:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return m}});var n=a(7378);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6031:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var n=a(5773),o=a(808),r=(a(7378),a(5318)),i=["components"],s={title:"Type-Safe Relations",sidebar_position:3},l=void 0,p={unversionedId:"goals/type-safe-relations",id:"goals/type-safe-relations",isDocsHomePage:!1,title:"Type-Safe Relations",description:"Relations are Async By Default",source:"@site/docs/goals/type-safe-relations.md",sourceDirName:"goals",slug:"/goals/type-safe-relations",permalink:"/joist-ts/docs/goals/type-safe-relations",editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/goals/type-safe-relations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Type-Safe Relations",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Avoiding N+1s",permalink:"/joist-ts/docs/goals/avoiding-n-plus-1s"},next:{title:"Great Testing",permalink:"/joist-ts/docs/goals/great-tests"}},c=[{value:"Relations are Async By Default",id:"relations-are-async-by-default",children:[],level:2},{value:"The Magic But Safe Escape Hatch",id:"the-magic-but-safe-escape-hatch",children:[],level:2}],u={toc:c};function d(e){var t=e.components,a=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"relations-are-async-by-default"},"Relations are Async By Default"),(0,r.kt)("p",null,"Joist takes the strong opinion that any operation that ",(0,r.kt)("em",{parentName:"p"},"might")," be lazy loaded (like accessing an ",(0,r.kt)("inlineCode",{parentName:"p"},"author.books")," collection that may or may not already be loaded in memory) ",(0,r.kt)("em",{parentName:"p"},"must")," be marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),"."),(0,r.kt)("p",null,"Other ORMs in the JS/TS space often fudge this, i.e. they might model an ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"books: Book[]")," property where you can get the pleasantness of accessing ",(0,r.kt)("inlineCode",{parentName:"p"},"author.books")," without ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),"s/",(0,r.kt)("inlineCode",{parentName:"p"},"Promise.all"),"/etc. code--as long as whoever loaded this ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," instance ensured that ",(0,r.kt)("inlineCode",{parentName:"p"},"books")," was already fetched/initialized."),(0,r.kt)("p",null,'This seems great in the short-term, but Joist asserts its dangerous in the long-term, because code written to rely on the "',(0,r.kt)("inlineCode",{parentName:"p"},"author.books")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Book[]"),'" assumption is now coupled to ',(0,r.kt)("inlineCode",{parentName:"p"},"author.books")," being pre-fetched and ",(0,r.kt)("em",{parentName:"p"},"always")," being present, regardless of the caller."),(0,r.kt)("p",null,"This sort of implementation detail is easy to enforce when the synchronous-assuming (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"for (book in author.books)"),') is 5 lines below the "load author with a ',(0,r.kt)("inlineCode",{parentName:"p"},"books")," preload hint\" in the same file. However it's very hard to enforce in a large codebase, when business logic and validation rules can be triggered from multiple operation endpoints. And, so when ",(0,r.kt)("inlineCode",{parentName:"p"},"author.books")," is ",(0,r.kt)("em",{parentName:"p"},"not"),' loaded, it will at best cause a runtime error ("hey you tried to access this unloaded collection") and at worst cause a very obscure bug (by returning a falsely empty collection or unset reference).'),(0,r.kt)("p",null,'Essentially this approach of having non-async collections creates a contract ("',(0,r.kt)("inlineCode",{parentName:"p"},"author.books"),' must somehow be loaded") that is not present in the type system, so now the programmer/maintainer must remember and self-enforce it.'),(0,r.kt)("h2",{id:"the-magic-but-safe-escape-hatch"},"The Magic But Safe Escape Hatch"),(0,r.kt)("p",null,'So Joist does not do that, all references/collections are "always ',(0,r.kt)("inlineCode",{parentName:"p"},"async"),'".'),(0,r.kt)("p",null,"...",(0,r.kt)("em",{parentName:"p"},"that said"),', writing business logic across a few collections that you "know" are in memory but have to use promises anyway is extremely tedious.'),(0,r.kt)("p",null,"So, Joist has a way to explicitly mark subsets of fields, on subsets of object instances, as preloaded and so safe to synchronously access."),(0,r.kt)("p",null,"This looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// Note the `{ author: "publisher" } preload hint\nconst book = await em.populate(originalBook, { author: "publisher" });\n// The `populate` return type is a "special" `Book` that has `author` and `publisher` marked as "get-safe"\nexpect(book.author.get.firstName).toEqual("a1");\nexpect(book.author.get.publisher.get.name).toEqual("p1");\n')),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"originalBook"),"'s references (",(0,r.kt)("inlineCode",{parentName:"p"},"book.author"),") could ",(0,r.kt)("em",{parentName:"p"},"not")," call ",(0,r.kt)("inlineCode",{parentName:"p"},".get")," (only ",(0,r.kt)("inlineCode",{parentName:"p"},".load")," which returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),"), however, the return value of ",(0,r.kt)("inlineCode",{parentName:"p"},"em.populate")," uses mapped types to transform only the fields listed in the hint (",(0,r.kt)("inlineCode",{parentName:"p"},"author")," and the nested ",(0,r.kt)("inlineCode",{parentName:"p"},"author.publisher"),") to be safe for synchronous access, so the calling code can now call ",(0,r.kt)("inlineCode",{parentName:"p"},".get")," and avoid the fuss of promises (only for this section of ",(0,r.kt)("inlineCode",{parentName:"p"},"populate"),"-blessed code)."),(0,r.kt)("p",null,"Most of Joist's ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityManager")," take a ",(0,r.kt)("inlineCode",{parentName:"p"},"populate")," parameter to help you return data both a) already loaded from the database, and b) ",(0,r.kt)("em",{parentName:"p"},"marked in the type system as loaded")," to achieve the pleasantness of synchronous access without the risks of mis-modeling references as always/naively loaded."),(0,r.kt)("p",null,"As one more helpful feature, you can also navigate across multiple levels of the object graph with a single async call using ",(0,r.kt)("inlineCode",{parentName:"p"},"Entity.load"),", i.e.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// await way\nconst allAuthorReviews = (await Promise.all(await author.books.load()).map((b) => b.comments.load())).flat();\n// lens navigation way\nconst allAuthorReviews = await author.load((a) => a.books.comments);\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"a.books.comments")," acts similar to a ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/@dtipson/functional-lenses-d1aba9e52254"},"lens"),", and defines a (type safe) path that ",(0,r.kt)("inlineCode",{parentName:"p"},"load")," then recursively/asynchronously navigates for you, with the convenience of only having a single ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," call in your code."))}d.isMDXComponent=!0}}]);