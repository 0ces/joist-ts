"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[449],{5318:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var i=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,g=c["".concat(l,".").concat(m)]||c[m]||d[m]||r;return n?i.createElement(g,o(o({ref:t},u),{},{components:n})):i.createElement(g,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1771:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return c}});var i=n(5773),a=n(808),r=(n(7378),n(5318)),o=["components"],s={title:"Tagged Ids"},l=void 0,p={unversionedId:"features/tagged-ids",id:"features/tagged-ids",isDocsHomePage:!1,title:"Tagged Ids",description:'Joist automagically "tags" entity ids, which means prefixing them with a per-entity identifier.',source:"@site/docs/features/tagged-ids.md",sourceDirName:"features",slug:"/features/tagged-ids",permalink:"/joist-ts/docs/features/tagged-ids",editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/features/tagged-ids.md",tags:[],version:"current",frontMatter:{title:"Tagged Ids"},sidebar:"tutorialSidebar",previous:{title:"Relation Helpers",permalink:"/joist-ts/docs/features/relation-helpers"},next:{title:"unit-of-work",permalink:"/joist-ts/docs/features/unit-of-work"}},u=[],d={toc:u};function c(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'Joist automagically "tags" entity ids, which means prefixing them with a per-entity identifier.'),(0,r.kt)("p",null,"For example, the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"author1.id")," is ",(0,r.kt)("inlineCode",{parentName:"p"},'"a:1"')," instead of the number ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,r.kt)("p",null,"There are a few reasons for this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"It eliminates a class of bugs where ids are passed incorrectly across entity types."),(0,r.kt)("p",{parentName:"li"},"For example, a bug like:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const authorId = someAuthor.id;\n// Ops this is the wrong id\nconst book = em.load(Book, authorId);\n")),(0,r.kt)("p",{parentName:"li"},'Often these "wrong id" bugs will work during local unit tests because every table only has a few rows of ',(0,r.kt)("inlineCode",{parentName:"p"},"id 1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"id 2"),", so it's easy to have ",(0,r.kt)("inlineCode",{parentName:"p"},"id 1")," taken from the ",(0,r.kt)("inlineCode",{parentName:"p"},"authors")," table and accidentally work when looking it up in the ",(0,r.kt)("inlineCode",{parentName:"p"},"books")," table."),(0,r.kt)("p",{parentName:"li"},"Note that Joist also has strongly-typed ids (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthorId"),') to help prevent this, but those can only fix "wrong id" bugs that are internal to the application layer\'s codebase, i.e. the above example of reading an id from an entity and then immediately using it to look up the "wrong" entity (specifically the above code, even without tagged ids, is a compile error in Joist).'),(0,r.kt)("p",{parentName:"li"},'However, tagged ids extends this same "strongly-typed ids" protection to API calls, i.e. if a client calls the API and gets back "author id 1" and then makes a follow up API call but accidentally uses that author id as a book id. Because we\'ve crossed an API boundary (which generally have more generic id types, i.e. GraphQL\'s ',(0,r.kt)("inlineCode",{parentName:"p"},"ID"),' type is used for all objects), we need to use a runtime value to catch that "this id is not for the right entity".'),(0,r.kt)("p",{parentName:"li"},'Granted, this will be a runtime error, but it will be a runtime error everytime time (i.e. even in local development when the "wrong id" often works by accident) instead of only showing up in production.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"It makes debugging easier because seeing ids like ",(0,r.kt)("inlineCode",{parentName:"p"},"a:1")," in the logs, you immediately know which entity that is for, without having to also prefix your logging statements with ",(0,r.kt)("inlineCode",{parentName:"p"},"authorId=${...}"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"GraphQL already uses essentially-strings/opaque ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," types, and while Joist is technically GraphQL-agnostic, pragmatically implementing a GraphQL system is what drove most of Joist's development, so it was generally easy to support this in our APIs, so seemed like a low-hanging-fruit/easy-win."))),(0,r.kt)("p",null,"Note that, in the database, the entity primary keys are still numeric / ",(0,r.kt)("inlineCode",{parentName:"p"},"serial")," integers. Joist just auto-tags/detags them for you/for free."),(0,r.kt)("p",null,"For the tags, Joist will guess a tag name to use by abbreviating the entity name, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"BookReview")," --\x3e ",(0,r.kt)("inlineCode",{parentName:"p"},"br"),". If there is a collision, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"br")," is already taken, it will use the full entity name, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"bookReview"),". Tags are stored ",(0,r.kt)("inlineCode",{parentName:"p"},"joist-codegen.json")," so you can easily change them if Joist initially guesses wrong."),(0,r.kt)("p",null,"Once you have a given tagged id deployed in production, you should probably never change it, i.e. in case id values like ",(0,r.kt)("inlineCode",{parentName:"p"},"a:1")," ends up in a 3rd party system, changing your tagged id to ",(0,r.kt)("inlineCode",{parentName:"p"},"author:1")," may break things."),(0,r.kt)("p",null,'Note that Joist will still look up "untagged ids" i.e. if you do ',(0,r.kt)("inlineCode",{parentName:"p"},'em.load(Author, "1")')," it will not complain about the lack of a tag. However, if the tag value is wrong, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},'em.load(Author, "b:1")'),", then it will be a runtime failure."))}c.isMDXComponent=!0}}]);