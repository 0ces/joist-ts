---
title: Partial Update APIs
---

Joist has built-in support for building "partial update"-style APIs on top of your domain model.

Partial update APIs, whether they are implemented over REST or GraphQL or GRPC, typically follow the conventions of:

* A create or update can include only a subset of fields, and any field not included in the subset is left as-is
* An update can use `null` as a marker to mean "unset this field"
* Updating a parent's collection of children can be done incrementally, i.e. w/o knowing the full set of children

Joist has dedicated `EntityManager.createOrUpdatePartial` and `Entity.setPartial` APIs to help implement APIs that follow these conventions with as little boilerplate as possible.

These methods are also useful specifically for implementing GraphQL APIs, where the normal `EntityManager.create` and `Entity.set` methods have TypeScript types that are too strict for GraphQL's looser/less strict type system. For example, a `SaveAuthorInput` `firstName` that is generated by [graphql-code-generator](https://graphql-code-generator.com) might be typed as `firstName: string | null | undefined` which does not match Joist's more idiomatic `Author.firstName: string | undefined` typing.

## Unsetting Fields with `null` Marker

A common pattern for partial-update style APIs is to treat `null` and `undefined` differently, i.e. `{ firstName: null }` specifically means "unset the `firstName` property" while `firstName` being not present (i.e. either `{ firstName: undefined }` or an empty `{}`) means "do not change `firstName`".

As mentioned, in a GraphQL input type this might be typed as `SaveAuthorInput` having a `firstName: string | null | undefined` field.

Normally the `null`-ness of input's `firstName` will cause issues with Joist's "preferred `undefined`" convention:

```typescript
// This is typed as string | null | undefined
const { firstName } = saveAuthorInput;
const author = em.load(Author, "1");
// The normal `.set` will not compile
author.set({ firstName });
}
```

Instead, Joist provides a `setPartial` that allows code to opt-in to the partial-semantic behavior and an RPC layer's potentially-less-strict typing:

```typescript
// This is typed as string | null | undefined
const { firstName } = saveAuthorInput;
const author = em.load(Author, "1");
// Compiles successfully
author.setPartial({ firstName });
}
```

Specifically, the semantics of `Entity.setPartial` is that:

- For a required field `firstName`: 
  - `{ firstName: "foo" }` will update `firstName`
  - `{ firstName: undefined }` or `{}` will do nothing
  - `{ firstName: null }` will be a runtime error b/c `firstName` is required and cannot be `null`
- For an optional field `lastName`: 
  - `{ lastName: "bar" }` will update `lastName`
  - `{ lastName: undefined }` or `{}` will do nothing
  - `{ lastName: null }` will unset `lastName` (i.e. set it as `undefined`)

The `EntityManager.createPartial` and `EntityManager.createOrUpdatePartial` methods both have these semantics as well.

:::info

Arguably, the ideal partial-update type for `Author` in this scenario would be:

```typescript
interface SaveAuthorInput {
  firstName: string | undefined;
  lastName: string | null | undefined;
}
```

But sometimes it's a challenge to get the RPC framework, e.g. GraphQL in this instance, to generate a type that exactly matches this, which is why Joist offers these more flexible `setPartial` methods.

:::

## Saving Parents with Children

To save both a parent and multiple potentially-new-or-existing children, Joist provides `EntityManager.createOrUpdatePartial`.

An example usage is:

```typescript
// Given some RPC types (in this instance GraphQL)
interface SaveAuthorInput {
  id?: string | null;
  firstName?: string | null;
  books?: SaveBookInput[];
}
interface SaveBookInput {
  id?: string | null;
  title?: string | null;
  
}

// When the client's request comes in...
const input: SaveAuthorInput = {
  // Updating author 1
  id: "a:1",
  // To have 3 books
  books: [
    // And the 1st book is new
    { title: "new book" },
    // And the 2nd book already exists but has no changes
    { id: "b:1" },
    // And the 3rd book already exists but has a new title 
    { id: "b:2", title: "updated" },
  ]
}

// Then we can apply all of those changes via
// a single call
await em.createOrUpdatePartial(Author, input);
```

Admittedly, your RPC/GraphQL API convention for parent/children inputs has to fairly closely follow what Joist's own partial update / `createOrUpdatePartial` convention, but assuming you do so, Joist can reduce a very large amount of CRUD boilerplate in an RPC/GraphQL API.

:::note

Unlike `EntityManager.create`, which is synchronous, `EntityManager.createOrUpdatePartial` is async and needs to be `await`-d because it may require SQL calls to look up existing entities, e.g. the `b:1` and `b:2` IDs in the above example.

:::

:::info

Joist's `createOrUpdatePartial` behavior, while developed independently, is effectively similar Objection.js's [`upsertGraph`](https://vincit.github.io/objection.js/guide/query-examples.html#graph-upserts) operation.

:::

## Incremental Collection Updates

Joist's default behavior for any collection set (e.g. `Entity.set`, `Entity.setPartial`, `EntityManger.createOrUpdatePartial`, etc.) is for the collection to be exhaustively set to the new value, for example:

```typescript
const author = newAuthor(em);
// Start out with two books
author.set({ books: [b1, b2] });
// Later set with a third book
author.set({ books: [b3] });
// Passes b/c `set` has implicitly removed the 1st two books
expect(author.books.get.length).toEqual(1);
```

However, when partially updating entities via an RPC call, it's often convenient to change only a single child of the collection, especially for APIs where the child itself doesn't have a dedicated operation (i.e. saving an invoice line item can only be done via the invoice API).

To support these APIs, `setPartial` and `createOrUpdatePartial` will both opt-in to incremental collection semantics if they detect an extra `op` hint key on the children. For example:

```typescript
const author = newAuthor(em);
// Start out with two books
author.set({ books: [b1, b2] });
// Later add a third book
author.setPartial({ books: [
  // And include the `op` hint
  { op: "include", title: "b3" }
]});
// Passes b/c `setPartial` saw `op` and worked incrementally
expect(author.books.get.length).toEqual(3);
```

The valid values of an `op` keyword are:

* `{ op: "delete", id: ... }` will remove the child and `EntityManager.delete` it for hard deletion
* `{ op: "remove", id: ... }` will remove the child but not call `EntityManager.delete`
* `{ op: "include", id: ... }` will include (i.e. add if needed, or just update if it already an existing child) the child
* `{ op: "incremental" }` is a non-entity marker to flip `setPartial` into incremental mode even when the list might be empty

:::caution

Admittedly, the fourth `op: "incremental"` option in particular looks kind of odd.

It exists so that incremental operations that would otherwise "not do anything" do not look like "set this collection to empty", i.e.:

```typescript
// This would clear the books
author.setPartial({ books: [] });
// But what we really want is "do nothing", so pass the incremental
// marker without any other entries in the array
author.setPartial({ books: [{ op: "incremental" }] });
```

The idea is that it would be easier/more explicit for clients to always include this `op: "incremental"` marker, than to conditionally not send the `books` key at all when there are no operations to perform.

But we probably need a cleaner way to indicate this, or just enforce that clients should know not to send in an empty list if they have no operations to perform.

:::

## Legacy Incremental Collection Updates

Joist's initial version of incremental updates used separate `delete` and `remove` keys instead of `op`:

```typescript
const author = newAuthor(em);
// Start out with three books
author.set({ books: [b1, b2, b3] });
// Then delete b1, remove b2, leave b3 alone, and add b4
author.setPartial({ books: [
  { id: "b:1", delete: true },
  { id: "b:2", remove: true },
  { id: "b:4" },
]});
```


